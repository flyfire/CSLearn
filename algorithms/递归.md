 递归
 
[toc]

## 1. 理论

在计算思维中，最重要的是一种自顶向下、先全局后局部的逆向思维，它被称为递归。

**递归是计算思维的核心**

递归是训练人逆向思考的能力。

人的思维通常是递推，即从小到大、从简单情况到复杂情况、自底向上拓展的，先把简单的问题搞清楚，看看能否找到规律，再用于复杂的问题。


**计算机思维通常是递归，自顶向下，先把大问题分解为小问题，小问题和大问题有着统一的结构和解决方法。**

### 递归思想的妙处:

1. 只要解决当前一步的问题，就能解决全部问题
2. 在解决问题的过程时，只要复制同一个过程即可
    
    前提条件是：
    
    - 首先，每一个问题在形式上都是相同的，否则无法通过同一个过程完成不同阶段的计算
    - 其次，必须确定好结束条件
    

### 递归算法的好处:

- 递归不需要总结所谓的普遍规律，只需要搞清楚如何拆解问题即可
- 递归的优点是以相同方式处理大问题和小问题，代码非常简洁移动

## 2.算法

### 2.1 使用场景

对一个序列进行排序、分析自然语言、规划行驶路径、实现两类集合之间的匹配等

### 2.2 具体的算法实现

**使用递归解决问题的条件**

1. 一个问题的解可以分解为几个子问题的解
2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样
3. 存在递归终止条件

编写递归代码的关键是写出递推公式，找到终止条件。

找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码

遇到递归，把它抽象成一个递归公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步奏。

**需要注意的问题**

1. 递归代码要警惕堆栈溢出
    
    解决办法是限制在递归调用的最大深度
    
2. 递归代码要警惕重复计算
    
    解决办法是用 hash 表保存已经求解过的 f(k). 当递归调用到 f(k)时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算。这样可以避免重复计算的问题。
    
    ```java
    public int f(int n) {
      if (n == 1) return 1;
      if (n == 2) return 2;
      
      // hasSolvedList 可以理解成一个 Map，key 是 n，value 是 f(n)
      if (hasSolvedList.containsKey(n)) {
        return hasSovledList.get(n);
      }
      
      int ret = f(n-1) + f(n-2);
      hasSovledList.put(n, ret);
      return ret;
    }
    ```
    
    ### 2.3 递归算法的模板
    
    1. **确定递归函数的参数和返回值：**
        
        确定哪个参数是递归的过程中需要处理的，就在递归函数中加上这个函数，并且还要明确每次递归返回值是什么进而确定递归返回返回类型
        
    2. **确定终止条件**：
        
        写完递归算法，运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或终止条件写的不对，操作系统也是用一个栈的结构保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出
        
    3. **确定单层递归的逻辑**
        
        确定每一层递归需要处理的信息，这里会重复调用自己来实现递归的过程。
        
    
    例子：
    
    **确定递归函数的参数和返回值：**
    
    ```java
    void traversal(TreeNode* cur, vector<int>& ver)
    ```
    
    **确定终止条件**：
    
    ```java
    if(cur == NULL) return;
    ```
    
    **确定单层递归的逻辑**
    
    ```java
    vec.push_back(cur->val); // 中
    traversal(cur->left, vec); // 左
    traversal(cur->right, vec); // 右
    ```
    
    整体代码，前序遍历
    
    ```c
    class Solution {
    public:
    void traversal(TreeNode* cur, vector<int>& vec) {
        if (cur == NULL) return;
        vec.push_back(cur->val); // 中
        traversal(cur->left, vec); // 左
        traversal(cur->right, vec); // 右
    }
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        traversal(root, result);
        return result;
        }
    };
    ```
    
    ## 3. 参考
    
    - 吴军《计算之魂》
    - 极客时间 《数据结构与算法之美》

